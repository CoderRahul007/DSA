# Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number 
# of different non-empty subsets with the maximum bitwise OR.

# An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.
#  Two subsets are considered different if the indices of the elements chosen are different.

# The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).

 

# Example 1:

# Input: nums = [3,1]
# Output: 2
# Explanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:
# - [3]
# - [3,1]

# Example 2:

# Input: nums = [2,2,2]
# Output: 7
# Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 2^3 - 1 = 7 total subsets.

# Example 3:

# Input: nums = [3,2,1,5]
# Output: 6
# Explanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:
# - [3,5]
# - [3,1,5]
# - [3,2,5]
# - [3,2,1,5]
# - [2,5]
# - [2,1,5]
##############################################################################################################

class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        maxPossible = 0
        
        for n in nums:
            maxPossible |= n
        
        ans = [0]
        
        def solve(nums, index, prev, maxPossible):
            if index == len(nums):
                return
            
            # choose current item
            curr = prev | nums[index]
            
            if curr == maxPossible:
                ans[0] += 1
            
            solve(nums, index + 1, curr, maxPossible)
            # not choose current item
            solve(nums, index + 1, prev, maxPossible)
        
        solve(nums, 0, 0, maxPossible)
        return ans[0]
# 2^n * n
#         
##############################################################################################################
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        sub = []
        
        #function to find all the possible subarrays 
        def helper(arr, index, subarr):

            if index == len(arr):
                if len(subarr) != 0:
                    sub.append(subarr)
            else:
                helper(arr, index + 1, subarr)
                helper(arr, index + 1, subarr + [arr[index]])
               
            return
                
        #function to check if the OR of a array is equal to a given value
        def checker(arr,maxOR):
            OR = arr[0]
            for i in range(1, len(arr)):
                OR = OR|arr[i]
            return OR == maxOR
            
        helper(nums,0,[]) 
        
        #calculating maximum possible OR of an array
        maxOR = nums[0]
        for i in range(1, len(nums)):
            maxOR = maxOR|nums[i]
        
        #traverse the list "sub" generated by calling "helper" and checking if the value is equal to maxOR
        count = 0
        for arr in sub :
            if checker(arr,maxOR) :
                count+=1
        
        return count
