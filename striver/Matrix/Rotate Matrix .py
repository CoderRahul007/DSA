# Problem Statement
# Given a 2-dimensional matrix of size ‘N’ x ‘M’, rotate the elements of the matrix clockwise.

# For example: 
# Input Matrix: [ [ 1, 2, 3 ] 
#                 [ 4, 5, 6 ] 
#                 [ 7, 8, 9 ] ]

# Output Matrix: [ [ 4, 1, 2 ] 
#                  [ 7, 5, 3 ] 
#                  [ 8, 9, 6 ] ]

# The output matrix is generated by rotating the elements of the input matrix in a clockwise direction. 
# Note that every element is rotated only once. 

def rotateMatrix(mat, n, m):

    # Write your code here
    iu = 0
    id = n-1
    jl = 0
    jr = m-1
    if id == 0 or jr == 0:
        return
    while jl < jr and iu < id:

        temp = mat[iu][iu]

        for j in range(jl+1 , jr+1):
            temp , mat[iu][j] = mat[iu][j] , temp

        for i in range(iu+1 , id+1):
            temp , mat[i][jr] = mat[i][jr] , temp

        j = jr-1
        while j >= jl:
            temp , mat[id][j] = mat[id][j] , temp
            j-=1
            
        i = id-1
        while i >= iu:
            temp , mat[i][jl] = mat[i][jl] , temp
            i-=1
        
        iu+=1
        id-=1
        jl+=1
        jr-=1

#  Iterative

# The idea is the same as used in the previous algorithm. We will consider
#  the given matrix in the form of rings/squares, and this time, we will rotate the matrix in an iterative manner. 
 

# Algorithm: 

#     Initialise two variables, ‘row’ and ‘col’ to keep track of 
#     the starting row and starting column of the current ring. 
#     Ending row and ending column can be tracked by N and M.
#     Starting from the outer ring, keep rotating the inner rings, if it exists.
#     For each ring/square of the matrix:
#         Move the elements of the top side.
#         Move the elements of the right side.
#         Move the elements of the bottom side.
#         Move the elements of the left side.
#         Update the ‘row’, ‘col’, ‘N’ and ‘M’ for the next inner ring.

# Time Complexity

# O(N * M), where N is the number of rows and M is the number of columns in the matrix. 

 

# Since we are traversing each element of the matrix just once, the time complexity of the above algorithm is O(N * M). 
# Space Complexity

# O(1)

 

# We are not using any extra data structure, as we are updating the given matrix.
#  Only constant extra space is required. Thus, the space complexity is O(1).

'''

	Time Complexity: O(N * M)
	Space Complexity: O(1)

	Where N, M are the number of rows and the number of columns of the matrix, respectively.

'''


def rotateMatrix(mat, n, m):

    row = 0
    col = 0

    ''' 
       row - Staring row index 
       m - ending row index 
       col - starting column index 
       n - ending column index  
    '''

    while (row < n and col < m):

        # If we have rotated the whole matrix
        if (row == n - 1 or col == m - 1):
            break

        # Store the first element of next row as this element will replace first element of current row
        previous = mat[row + 1][col]

        # Move elements of first row from the remaining rows
        for i in range(col, m):
            current = mat[row][i]
            mat[row][i] = previous
            previous = current

        row += 1

        # Move elements of last column from the remaining columns
        for i in range(row, n):
            current = mat[i][m-1]
            mat[i][m-1] = previous
            previous = current

        m -= 1

        # Move elements of last row from the remaining rows
        if (row < n):
            for i in range(m-1, col-1, -1):
                current = mat[n-1][i]
                mat[n-1][i] = previous
                previous = current

        n -= 1

        # Move elements of first column from the remaining rows
        if (col < m):
            for i in range(n-1, row-1, -1):
                current = mat[i][col]
                mat[i][col] = previous
                previous = current

        col += 1


################################################################################################
# Recursion

#  Recursion

# The idea is to consider the matrix in the form of rings and then rotate each ring recursively. 
# One ring will be rotated in one recursive call. 

# An image showing all the rings in a matrix is given below: 

# There are two rings in the above matrix. The outer ring is shown in the yellow colour, 
# and the inner ring is shown in the blue colour.  It’s easy to rotate the elements in the form of rings. 

# Matrix after rotating the outer ring: 

# Matrix after rotating the inner ring: 

# As there is no more ring, this is the modified output matrix. 
 

# Algorithm: 

#     Create a helper function which takes the indices of the current ring as parameters,
#      i.e the starting row index, ending row index, starting column index, ending column index.
#     Call the helper function for the outer ring.
#     In the helper function,
#         Check the base condition, i.e. whether the indices of the ring are valid or not.
#         Rotate the current ring as:
#             Move the elements of the top side.
#             Move the elements of the right side.
#             Move the elements of the bottom side.
#             Move the elements of the left side.
#         Recursively call the function for the inner ring by passing the indices of the inner ring as parameters.

# Time Complexity

# O(N * M), where N is the number of rows and M is the number of columns in the matrix. 

 

# Since we are traversing each element of the matrix just once, the time complexity of the above algorithm is O(N * M). 
# Space Complexity

# O(max(N, M)), where N is the number of rows and M is the number of columns in the matrix. 

 

# We are making max(N/2, M/2) recursive calls and thus, stack space will be used. Hence, the space complexity is O(max(N, M)). 

'''

	Time Complexity: O(N * M)
	Space Complexity: O(max(N, M)), 

    Where N is the number of rows and M is the number of columns in the matrix.

'''


def rotateMatrixHelper(mat, rowStart, colStart, rowEnd, colEnd):

    # Base Condition
    if(rowStart >= rowEnd or colStart >= colEnd):
        return

    if (rowStart >= rowEnd - 1 or colStart >= colEnd - 1):
        return

    previous = mat[rowStart + 1][colStart]
    current = previous

    # Move elements of first row from the remaining rows
    for i in range(colStart, colEnd):

        current = mat[rowStart][i]
        mat[rowStart][i] = previous
        previous = current

    rowStart += 1

    # Move elements of last column from the remaining columns
    for i in range(rowStart, rowEnd):

        current = mat[i][colEnd-1]
        mat[i][colEnd-1] = previous
        previous = current

    colEnd -= 1

    # Move elements of last row from the remaining rows
    if (rowStart < rowEnd):
        for i in range(colEnd - 1, colStart - 1, -1):

            current = mat[rowEnd-1][i]
            mat[rowEnd-1][i] = previous
            previous = current

    rowEnd -= 1

    # Move elements of first column from the remaining rows
    if (colStart < colEnd):
        for i in range(rowEnd-1, rowStart-1, -1):

            current = mat[i][colStart]
            mat[i][colStart] = previous
            previous = current

    colStart += 1

    # Recursively rotate inner rings
    rotateMatrixHelper(mat, rowStart, colStart, rowEnd, colEnd)


def rotateMatrix(mat, n, m):

    # Recursive function to rotate the matrix
    rotateMatrixHelper(mat, 0, 0, n, m)
